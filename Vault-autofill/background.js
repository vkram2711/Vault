// background.js
// Minimal background that proxies messages from content script to local vault API

const VAULT_BASE = "http://127.0.0.1:5000"; // adapt if your vault uses a different port

// Persisted unlock config (password + hashing preference).
async function getUnlockConfig() {
    return new Promise((resolve) => chrome.storage.local.get(["vault_password", "vault_use_argon2"], (data) => {
        resolve({
            password: data.vault_password || null,
            use_argon2: data.vault_use_argon2 !== false // default true
        });
    }));
}

async function setUnlockConfig(password, use_argon2) {
    return new Promise((resolve) => chrome.storage.local.set({
        vault_password: password || null,
        vault_use_argon2: use_argon2 !== false
    }, resolve));
}

// Attempt to unlock the vault once with provided credentials.
async function unlockVault(password, use_argon2 = true) {
    const res = await fetch(VAULT_BASE + "/unlock", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ password, use_argon2 })
    });
    if (!res.ok) {
        const txt = await res.text();
        throw new Error(`Vault unlock failed ${res.status}: ${txt}`);
    }
}

// Helper to call local vault API; if locked, try unlocking once then retry.
async function callVault(path, method = "GET", body = null) {
    const url = VAULT_BASE + path;
    const opts = {
        method,
        headers: { "Content-Type": "application/json" },
        body: body ? JSON.stringify(body) : undefined,
        // credentials: 'same-origin' // not needed for localhost
    };

    for (let attempt = 0; attempt < 2; attempt++) {
        const res = await fetch(url, opts);
        if (res.ok) {
            return res.json();
        }

        const txt = await res.text();
        const locked = res.status === 400 && txt && txt.toLowerCase().includes("vault locked");
        if (locked && attempt === 0) {
            // Unlock then retry once
            const cfg = await getUnlockConfig();
            if (!cfg.password) {
                throw new Error("Vault locked. Please unlock in the popup first.");
            }
            await unlockVault(cfg.password, cfg.use_argon2);
            continue;
        }
        throw new Error(`Vault API ${res.status}: ${txt}`);
    }
}

chrome.runtime.onMessage.addListener((msg, sender, sendResp) => {
    // msg: {action: "...", payload: {...}}
    (async () => {
        try {
            if (msg.action === "unlock_vault") {
                const { password, use_argon2 = true } = msg.payload || {};
                if (!password) throw new Error("Password required to unlock.");
                await unlockVault(password, use_argon2);
                await setUnlockConfig(password, use_argon2);
                sendResp({ ok: true });
                return;
            }

            if (msg.action === "generate_alias_and_credentials") {
                const { hostname, display_name, password_length = 16, mode = "word" } = msg.payload;

                // 1) Create alias (vault API)
                const aliasResp = await callVault("/alias", "POST", {
                    api_key: null,
                    hostname,
                    mode,
                    note: `Generated by extension for ${hostname}`
                });

                // 2) Generate password
                const pwdResp = await callVault("/password", "POST", {
                    length: password_length
                });

                // 3) Create identity in vault (optional: user provided display name)
                const identityResp = await callVault("/identity", "POST", {
                    domain: hostname,
                    name: display_name || aliasResp.alias.email,
                    pii: {
                        email: aliasResp.alias.email,
                        phone: null
                    },
                    site_type: "generic",
                    trust_level: 0
                });

                // 4) Create secret (store password)
                const secretResp = await callVault("/secret", "POST", {
                    item_id: identityResp.item_id,
                    secret_type: "password",
                    username: aliasResp.alias.email,
                    password: pwdResp.password
                });

                sendResp({ ok: true, alias: aliasResp.alias.email, password: pwdResp.password, item_id: identityResp.item_id, secret_id: secretResp.secret_id });
            }

            else if (msg.action === "autofill_login") {
                const { hostname } = msg.payload;

                // 1) Get items and find best candidate
                const items = await callVault("/items", "GET");
                // items should be an array with item_id and domain. We pick where domain matches hostname.
                const match = items.find(it => it[1] && it[1].includes(hostname)) || items.find(it => it[1] === hostname);
                // NOTE: adjust the index scheme depending on what /items returns
                if (!match) throw new Error("No matching vault entry found for this site.");

                // We assume svc.list_items returns rows like (item_id, domain, title, created_at, updated_at)
                const item_id = match[0];

                // fetch secrets for item -- we recommend adding endpoint /items/<item_id>/secrets
                const secrets = await callVault(`/items/${item_id}/secrets`, "GET");
                // choose the first password secret
                const pwdSecret = secrets.find(s => s.secret_type === "password");
                if (!pwdSecret) throw new Error("No password secret found for this item.");

                const secretLoad = await callVault(`/secret/${pwdSecret.secret_id}`, "GET");
                sendResp({ ok: true, username: secretLoad.username, password: secretLoad.password });
            }

            else if (msg.action === "ping_vault") {
                try {
                    await callVault("/items", "GET"); // simple probe
                    sendResp({ ok: true });
                } catch (e) {
                    sendResp({ ok: false, error: e.message });
                }
            }

            else {
                sendResp({ ok: false, error: "unknown action" });
            }
        } catch (err) {
            console.error("Background error:", err);
            sendResp({ ok: false, error: err.message });
        }
    })();

    // tell chrome we will respond asynchronously
    return true;
});
